<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WarpCore Benchmark: 3-Stage Benchmark (CPU, MEM, GPU)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the result screen */
        @keyframes pulse-ring {
            0% { transform: scale(0.3); opacity: 0.8; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        .animate-pulse-ring {
            animation: pulse-ring 1s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }
        .score-display {
            font-family: 'Inter', sans-serif;
            transition: all 0.3s ease-in-out;
        }
        canvas {
            display: none; /* Hidden by default, only used for calculation */
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'mem-color': '#f97316', /* Orange */
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-900 min-h-screen flex items-center justify-center p-4 text-gray-200">

    <div id="app-container" class="w-full max-w-3xl bg-gray-800 shadow-2xl rounded-xl p-8 transition-all duration-300">

        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl font-extrabold text-indigo-400">üöÄ WarpCore  Benchmark</h1>
            <p class="text-gray-400 mt-2">3-Stage Stress Test: CPU Recursion, Memory Thrashing, and WebGL Fractals.</p>
        </header>

        <!-- Main Content Area -->
        <main id="benchmark-area">
            
            <!-- Initial State / Ready to Start -->
            <div id="start-screen" class="text-center">
                <div class="text-6xl text-indigo-400 mb-6">‚öôÔ∏è</div>
                <h2 class="text-2xl font-semibold mb-4 text-white">Ready to Initialize?</h2>
                <p class="text-gray-400 mb-8">
                    This version includes a dedicated **Memory Thrashing Test** to evaluate your RAM performance and capacity.
                </p>
                <button id="startButton" class="w-full md:w-auto px-10 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-500 transition duration-150 transform hover:scale-105" onclick="startBenchmark()">
                    Start WarpCore
                </button>
            </div>

            <!-- Running State -->
            <div id="running-screen" class="hidden text-center">
                <div class="relative inline-flex mb-8">
                    <div class="w-16 h-16 bg-indigo-400 rounded-full animate-ping opacity-75"></div>
                    <div class="w-16 h-16 bg-indigo-600 rounded-full absolute top-0 left-0 flex items-center justify-center">
                        <div class="text-white font-bold text-xl" id="timerDisplay">...</div>
                    </div>
                </div>
                <h2 class="text-2xl font-semibold mb-2 text-white" id="currentTestTitle">Initializing...</h2>
                <p class="text-gray-400" id="currentTestDescription">Running heavy workload on a dedicated background thread...</p>
                <div class="mt-8 h-4 bg-gray-700 rounded-full overflow-hidden">
                    <div id="progressBar" class="h-full bg-indigo-500 transition-all duration-300" style="width: 0%;"></div>
                </div>
            </div>

            <!-- Result State -->
            <div id="result-screen" class="hidden text-center">
                <div class="relative p-6 mb-8">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <!-- Background Pulse Animation -->
                        <div class="w-28 h-28 bg-green-200 rounded-full animate-pulse-ring"></div>
                    </div>
                    <!-- Final Score Display -->
                    <div class="relative w-56 h-56 mx-auto bg-green-600 rounded-full flex flex-col items-center justify-center shadow-2xl">
                        <span class="text-7xl font-extrabold text-white score-display" id="finalScoreDisplay">0</span>
                        <span class="text-sm font-medium text-white/80 mt-1">WARPCORE RATING</span>
                    </div>
                </div>

                <div class="grid grid-cols-3 gap-4 text-left">
                    <!-- CPU SCORE CARD -->
                    <div class="bg-indigo-900/40 p-4 rounded-lg">
                        <h3 class="font-bold text-lg text-indigo-400">CPU Score</h3>
                        <p class="text-4xl font-extrabold text-indigo-200 mt-1 score-display" id="cpuScoreDisplay">0</p>
                        <p class="text-xs text-indigo-400 mt-1">Recursive Speed</p>
                    </div>
                    <!-- MEMORY SCORE CARD -->
                    <div class="bg-orange-900/40 p-4 rounded-lg">
                        <h3 class="font-bold text-lg text-mem-color">Memory Score</h3>
                        <p class="text-4xl font-extrabold text-orange-200 mt-1 score-display" id="memScoreDisplay">0</p>
                        <p class="text-xs text-mem-color mt-1">Thrashing & GC</p>
                    </div>
                    <!-- GPU SCORE CARD -->
                    <div class="bg-purple-900/40 p-4 rounded-lg">
                        <h3 class="font-bold text-lg text-purple-400">GPU Score</h3>
                        <p class="text-4xl font-extrabold text-purple-200 mt-1 score-display" id="gpuScoreDisplay">0</p>
                        <p class="text-xs text-purple-400 mt-1">Shader FPS</p>
                    </div>
                </div>

                <button class="mt-8 px-8 py-3 bg-gray-700 text-gray-200 font-bold rounded-lg hover:bg-gray-600 transition duration-150" onclick="resetBenchmark()">
                    Run Again
                </button>
            </div>
            
            <!-- The canvas is hidden as it's only used for computation -->
            <canvas id="gpuCanvas"></canvas>

        </main>
        
        <!-- Footer -->
        <footer class="text-center mt-8 pt-4 border-t border-gray-700 text-gray-600 text-xs">
            Performance metrics are relative to browser implementation and hardware. (C) Boyo Labs 2025 -- GPL License
        </footer>

    </div>

    <script>
        // Global state and constants
        // --- OPTIMIZED PARAMETERS ---
        const CPU_ITERATIONS = 10000;
        const FIB_N = 30;
        const CPU_REPORT_INTERVAL = 1000; // Report progress every 1000 iterations
        
        const MEM_BUFFER_COUNT = 50; // Number of large arrays to allocate/thrash
        const MEM_BUFFER_SIZE_MB = 100; // Size of each array (100MB)
        const MEM_TOTAL_SIZE_GB = (MEM_BUFFER_COUNT * MEM_BUFFER_SIZE_MB) / 1000;
        
        const GPU_DURATION_MS = 1500;
        const MANDELBROT_MAX_ITER = 400;

        // --- SCORING CALIBRATION (ADJUSTED FOR EQUAL WEIGHT) ---
        // Scores based on user input (CPU: 168, RAM: 402, GPU: 599) look good.
        // Calibration factors are maintained from the last successful balancing step.
        const CPU_CALIBRATION_FACTOR = 15000; 
        const MEM_CALIBRATION_FACTOR = 240; 
        const GPU_CALIBRATION_FACTOR = 10.0;  
        // --- END SCORING CALIBRATION ---

        const startScreen = document.getElementById('start-screen');
        const runningScreen = document.getElementById('running-screen');
        const resultScreen = document.getElementById('result-screen');
        const currentTestTitle = document.getElementById('currentTestTitle');
        const currentTestDescription = document.getElementById('currentTestDescription');
        const progressBar = document.getElementById('progressBar');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const cpuScoreDisplay = document.getElementById('cpuScoreDisplay');
        const memScoreDisplay = document.getElementById('memScoreDisplay'); // New element
        const gpuScoreDisplay = document.getElementById('gpuScoreDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const canvas = document.getElementById('gpuCanvas');

        let gl = null;
        let program = null;
        let isGpuTestRunning = false;
        let framesRendered = 0;

        /**
         * A lightweight sleep/yield function (mostly for GPU wait).
         */
        const yieldToUI = ms => new Promise(resolve => setTimeout(resolve, ms));

        // --- Web Worker Script (Runs CPU and Memory Tests) ---
        
        // This string contains the entire script that the Web Worker will execute.
        const workerScript = `
            const CPU_ITERATIONS = ${CPU_ITERATIONS};
            const FIB_N = ${FIB_N};
            const CPU_REPORT_INTERVAL = ${CPU_REPORT_INTERVAL};
            const MEM_BUFFER_COUNT = ${MEM_BUFFER_COUNT};
            const MEM_BUFFER_SIZE_MB = ${MEM_BUFFER_SIZE_MB};
            const MEM_BUFFER_SIZE_ELEMENTS = MEM_BUFFER_SIZE_MB * 1024 * 1024 / 8; // Float64Array is 8 bytes/element

            // CPU Heavy Calculation Function
            function cpuHeavyCalculation(n) {
                if (n <= 1) return n;
                if (n === 2) return 1;
                return (cpuHeavyCalculation(n - 1) + cpuHeavyCalculation(n - 2)) * Math.sin(n) / Math.PI;
            }

            // Memory Thrashing Function (RAM capacity and speed test)
            function memoryThrashingTest() {
                let buffers = [];
                let totalAccesses = 0;
                
                for (let i = 0; i < MEM_BUFFER_COUNT; i++) {
                    // 1. Allocation
                    let buffer = new Float64Array(MEM_BUFFER_SIZE_ELEMENTS);
                    
                    // 2. Filling and Random Access (to defeat cache)
                    for (let j = 0; j < 50000; j++) {
                         let randomIndex = Math.floor(Math.random() * MEM_BUFFER_SIZE_ELEMENTS);
                         buffer[randomIndex] = Math.random(); 
                    }
                    buffers.push(buffer);
                }
                
                // 3. Deallocation (Triggers Garbage Collection Stress)
                // Nullifying the references forces the browser to clean up ~5GB of allocated space.
                for(let i=0; i < buffers.length; i++) {
                    buffers[i] = null;
                }
                buffers = [];
                
                // Aggressively hint for GC (Though behavior is non-standard)
                if (typeof gc === 'function') {
                    gc(); 
                }
            }


            self.onmessage = function(e) {
                if (e.data.test === 'cpu') {
                    const startTime = performance.now();
                    for (let i = 0; i < CPU_ITERATIONS; i++) {
                        cpuHeavyCalculation(FIB_N);
                        // Report progress periodically
                        if (i > 0 && i % CPU_REPORT_INTERVAL === 0) {
                             self.postMessage({ type: 'progress', test: 'cpu', currentIteration: i });
                        }
                    }
                    const timeTaken = performance.now() - startTime;
                    self.postMessage({ type: 'complete', test: 'cpu', timeTaken: timeTaken });
                
                } else if (e.data.test === 'mem') {
                    const startTime = performance.now();
                    memoryThrashingTest();
                    const timeTaken = performance.now() - startTime;
                    self.postMessage({ type: 'complete', test: 'mem', timeTaken: timeTaken });
                }
            };
        `;

        let worker = null;
        let workerUrl = null;

        function initWorker() {
            if (worker) return;
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            workerUrl = URL.createObjectURL(blob);
            worker = new Worker(workerUrl);
        }

        function terminateWorker() {
            if (worker) {
                worker.terminate();
                URL.revokeObjectURL(workerUrl);
                worker = null;
            }
        }

        /**
         * Runs the CPU benchmark using the Web Worker.
         */
        function runCPUBenchmark() {
            currentTestTitle.textContent = "Test 1/3: CPU Core Velocity";
            timerDisplay.textContent = "CPU";
            progressBar.classList.remove('bg-mem-color', 'bg-purple-500');
            progressBar.classList.add('bg-indigo-500');
            
            return new Promise((resolve, reject) => {
                let startTime = performance.now();
                
                worker.onmessage = function(e) {
                    if (e.data.type === 'complete' && e.data.test === 'cpu') {
                        resolve(e.data.timeTaken);
                    } else if (e.data.type === 'progress' && e.data.test === 'cpu') {
                        // Update progress bar and description based on received iteration count
                        const current = e.data.currentIteration;
                        const progress = (current / CPU_ITERATIONS) * 100 * (1/3); // 1/3 of total progress
                        progressBar.style.width = `${progress}%`;
                        currentTestDescription.textContent = `Executing ${current.toLocaleString()} / ${CPU_ITERATIONS.toLocaleString()} recursive calculations...`;
                    }
                };

                worker.onerror = function(error) {
                    reject(new Error("CPU Worker failed: " + error.message));
                };

                currentTestDescription.textContent = `Executing 0 / ${CPU_ITERATIONS.toLocaleString()} recursive calculations...`;
                worker.postMessage({ test: 'cpu' });
                
                // Keep progress running visually in case the time is very long or progress messages are delayed
                // The progress messages from the worker will override this animation when received.
                const animateProgress = () => {
                     if (worker) {
                        const elapsed = performance.now() - startTime;
                        // Cap the animation to prevent it from going past 33.33% before the worker is done.
                        const maxTime = 10000; // Assume test should finish in less than 10 seconds
                        const progress = (elapsed / maxTime) * 100 * (1/3);
                        if (progress < 33.33) {
                             progressBar.style.width = `${progress}%`;
                             requestAnimationFrame(animateProgress);
                        }
                    }
                };
                requestAnimationFrame(animateProgress);
            });
        }
        
        /**
         * Runs the Memory benchmark using the Web Worker.
         */
        async function runMemoryBenchmark() {
            currentTestTitle.textContent = "Test 2/3: RAM Thrashing & GC Load";
            timerDisplay.textContent = "MEM";
            progressBar.classList.remove('bg-indigo-500', 'bg-purple-500');
            progressBar.classList.add('bg-mem-color');
            
            const baseProgress = 33.33; // Starts after CPU test
            
            return new Promise((resolve, reject) => {
                let startTime = performance.now();

                worker.onmessage = function(e) {
                    if (e.data.type === 'complete' && e.data.test === 'mem') {
                        resolve(e.data.timeTaken);
                    }
                };
                // We clear the CPU progress listener setup for this test
                worker.onerror = function(error) {
                    reject(new Error("Memory Worker failed: " + error.message));
                };

                currentTestDescription.textContent = `Allocating and thrashing ${MEM_BUFFER_COUNT} buffers, approx. ${MEM_TOTAL_SIZE_GB.toFixed(1)} GB total memory...`;
                worker.postMessage({ test: 'mem' });

                // Simple animation loop for progress
                const animateProgress = (elapsedTime) => {
                    if (worker && (performance.now() - startTime) < 5000) { // Assume max 5s for the MEM test
                        const elapsed = performance.now() - startTime;
                        const progress = (elapsed / 5000) * 100 * (1/3); // 1/3 of total progress
                        progressBar.style.width = `${baseProgress + progress}%`;
                        requestAnimationFrame(animateProgress);
                    }
                }
                requestAnimationFrame(animateProgress);
            });
        }
        
        // --- WebGL Setup and GPU Benchmark ---
        
        // Vertex Shader: Standard full-screen quad setup
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Mandelbrot Set Fragment Shader (Highly computationally intensive)
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            out vec4 outColor;
            uniform vec2 u_resolution;
            const int MAX_ITER = ${MANDELBROT_MAX_ITER}; 

            vec3 get_color(int iterations) {
                if (iterations == MAX_ITER) {
                    return vec3(0.0, 0.0, 0.0);
                }
                float t = float(iterations) / float(MAX_ITER);
                return 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.3, 0.6)));
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution;

                vec2 c = vec2(
                    mix(-2.5, 1.0, uv.x),
                    mix(-1.25, 1.25, uv.y)
                );

                vec2 z = vec2(0.0, 0.0);
                int iterations = 0;

                for (int i = 0; i < MAX_ITER; ++i) {
                    float x = z.x * z.x - z.y * z.y + c.x;
                    float y = 2.0 * z.x * z.y + c.y;
                    z = vec2(x, y);

                    if (dot(z, z) > 4.0) {
                        iterations = i;
                        break;
                    }
                    iterations = i + 1;
                }

                outColor = vec4(get_color(iterations), 1.0);
            }
        `;

        /**
         * Initializes the WebGL context and shaders. (Same as before)
         */
        function initWebGL() {
             gl = canvas.getContext('webgl2');
             if (!gl) return false;
             // Shader compilation and linking logic (omitted for brevity, assume success)
             const compileShader = (source, type) => {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            };

            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) return false;
            gl.useProgram(program);

            const positions = new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]);
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            const aPositionLoc = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(aPositionLoc);
            gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);
            const uResolutionLoc = gl.getUniformLocation(program, 'u_resolution');

            canvas.width = 1000;
            canvas.height = 1000;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);
            return true;
        }

        function gpuDrawLoop(timestamp) {
            if (!isGpuTestRunning || !gl) return;
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            gl.finish(); 
            framesRendered++;
            requestAnimationFrame(gpuDrawLoop);
        }
        
        /**
         * Runs the GPU benchmark test. (Same logic, progress adjusted for 1/3)
         */
        async function runGPUBenchmark() {
            currentTestTitle.textContent = "Test 3/3: GPU Shader Velocity";
            timerDisplay.textContent = "GPU";
            progressBar.classList.remove('bg-indigo-500', 'bg-mem-color');
            progressBar.classList.add('bg-purple-500');
            
            const baseProgress = 66.66; 
            
            if (!initWebGL()) {
                currentTestDescription.textContent = "WebGL 2.0 not supported. Skipping GPU test.";
                progressBar.style.width = '100%'; 
                await yieldToUI(500);
                return 0; 
            }
            
            currentTestDescription.textContent = `Rendering high-complexity fractal for ${GPU_DURATION_MS / 1000} seconds...`;
            
            framesRendered = 0;
            isGpuTestRunning = true;
            let startTime = performance.now();
            
            requestAnimationFrame(gpuDrawLoop);

            const updateInterval = 100;
            for (let timePassed = 0; timePassed < GPU_DURATION_MS; timePassed += updateInterval) {
                await yieldToUI(updateInterval);
                const elapsed = Math.min(timePassed + updateInterval, GPU_DURATION_MS);
                const progress = (elapsed / GPU_DURATION_MS) * 100 * (1/3); // 1/3 of total
                progressBar.style.width = `${baseProgress + progress}%`;
            }

            isGpuTestRunning = false;
            let actualTime = performance.now() - startTime;

            if (gl) {
                gl.getExtension('WEBGL_lose_context')?.loseContext();
                gl = null;
            }
            
            const averageFPS = framesRendered / (actualTime / 1000);
            return averageFPS;
        }

        /**
         * Main function to coordinate the benchmark tests.
         */
        async function startBenchmark() {
            startScreen.classList.add('hidden');
            resultScreen.classList.add('hidden');
            runningScreen.classList.remove('hidden');

            let cpuTimeMs = 0;
            let memTimeMs = 0;
            let gpuFPS = 0;

            initWorker();

            try {
                // 1. CPU Test 
                cpuTimeMs = await runCPUBenchmark();
                
                // 2. Memory Test
                memTimeMs = await runMemoryBenchmark();
                
                // 3. GPU Test
                gpuFPS = await runGPUBenchmark();

                terminateWorker();

                // Finalization
                progressBar.style.width = '100%';
                currentTestTitle.textContent = "WarpCore Benchmark Complete!";
                currentTestDescription.textContent = "Calculating final performance rating...";
                timerDisplay.textContent = "‚úÖ";
                
                await yieldToUI(500);

            } catch (error) {
                terminateWorker();
                currentTestTitle.textContent = "A Critical Error Occurred";
                currentTestDescription.textContent = "The test failed. Console log may contain details about Web Worker or WebGL issues.";
                console.error("Benchmark Execution Error:", error);
                await yieldToUI(3000);
                resetBenchmark();
                return;
            }

            // --- Scoring ---

            // CPU Score: Faster time is better.
            const cpuScore = Math.floor(CPU_CALIBRATION_FACTOR * (1000 / cpuTimeMs));

            // Memory Score: Faster time is better (heavily penalizes swapping/paging).
            const memScore = Math.floor(MEM_CALIBRATION_FACTOR * (1000 / memTimeMs));
            
            // GPU Score: Higher FPS is better.
            const gpuScore = Math.floor(gpuFPS * GPU_CALIBRATION_FACTOR);

            // Final Score
            const finalScore = cpuScore + memScore + gpuScore;

            // --- Display Results ---
            runningScreen.classList.add('hidden');
            resultScreen.classList.remove('hidden');

            cpuScoreDisplay.textContent = cpuScore.toLocaleString();
            memScoreDisplay.textContent = memScore.toLocaleString();
            gpuScoreDisplay.textContent = gpuScore.toLocaleString();

            // Animate final score
            let currentScore = 0;
            const scoreInterval = setInterval(() => {
                if (currentScore < finalScore) {
                    currentScore += Math.ceil((finalScore - currentScore) / 10); 
                    if (currentScore >= finalScore) currentScore = finalScore;
                    finalScoreDisplay.textContent = currentScore.toLocaleString();
                } else {
                    clearInterval(scoreInterval);
                    finalScoreDisplay.textContent = finalScore.toLocaleString();
                }
            }, 30);

            console.log("--- Warp Core Check Results ---");
            console.log(`CPU Time: ${cpuTimeMs.toFixed(2)}ms, Score: ${cpuScore}`);
            console.log(`MEM Time: ${memTimeMs.toFixed(2)}ms, Score: ${memScore}`);
            console.log(`GPU FPS: ${gpuFPS.toFixed(2)}, Score: ${gpuScore}`);
            console.log(`FINAL WARP CORE RATING: ${finalScore}`);
        }

        /**
         * Resets the application state to the start screen.
         */
        function resetBenchmark() {
            terminateWorker();
            startScreen.classList.remove('hidden');
            runningScreen.classList.add('hidden');
            resultScreen.classList.add('hidden');
            progressBar.style.width = '0%';
        }

    </script>
</body>
</html>